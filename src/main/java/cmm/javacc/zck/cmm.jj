options { 
    STATIC = false;
}

PARSER_BEGIN(CMMParser) 
package cmm.javacc.zck;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileNotFoundException;

class CMMParser {
    static final String TEST_FILE_PATH = "C:\\Users\\andys\\source\\repos\\cmm-javacc-zck\\src\\main\\java\\cmm\\javacc\\zck\\test.cmm";
    public static void main( String[] args ) throws ParseException, TokenMgrError, FileNotFoundException {
        File file = new File(TEST_FILE_PATH);
        BufferedReader br = new BufferedReader(new FileReader(file));
        CMMParser parser = new CMMParser(br);
        parser.Sentences();
    }
}
PARSER_END(CMMParser)

SKIP : { " " }
SKIP : { "\n" | "\r" | "\r\n" }
SKIP : { "/*" : WithinMultiComment }
<WithinMultiComment> SKIP : { "*/" : DEFAULT}
<WithinMultiComment> MORE : { < ~[] > }
SKIP : { "//" : WithinLineComment }
<WithinLineComment> SKIP : { "\r" | "\n" | "\r\n" : DEFAULT}
<WithinLineComment> MORE : { < ~[] > }
TOKEN : { < IF: "if" > }
TOKEN : { < ELSE: "else" > }
TOKEN : { < WHILE: "while" > }
TOKEN : { < BREAK: "break" > }
TOKEN : { < CONTINUE: "continue" > }
TOKEN : { < RETURN: "return" > }
TOKEN : { < INT: "int" > }
TOKEN : { < REAL: "real" > }
TOKEN : { < CHAR: "char" > }
TOKEN : { < VOID: "void" > }
TOKEN : { < LCB: "{" > }
TOKEN : { < RCB: "}" > }
TOKEN : { < SEMI: ";" > }
TOKEN : { < LRB: "(" > }
TOKEN : { < RRB: ")" > }
TOKEN : { < ASN: "=" > }
TOKEN : { < LSB: "[" > }
TOKEN : { < RSB: "]" > }
TOKEN : { < LT: "<" > }
TOKEN : { < LTE: "<=" > }
TOKEN : { < EQ: "==" > }
TOKEN : { < NEQ: "<>" > }
TOKEN : { < GT: ">" > }
TOKEN : { < GTE: ">=" > }
TOKEN : { < ADD: "+" > }
TOKEN : { < SUB: "-" > }
TOKEN : { < MUL: "*" > }
TOKEN : { < DIV: "/" > }
TOKEN : { < CMMA: "," > }
TOKEN : { < LAND: "&&" > }
TOKEN : { < BAND: "&" > }
TOKEN : { < LOR: "||" > }
TOKEN : { < BOR: "|" > }
TOKEN : { < BXOR: "^" > }
TOKEN : { < LNT: "!" > }
TOKEN : { < BNT: "~" > }
TOKEN : { < DEC: "--" > }
TOKEN : { < INC: "++" > }
TOKEN : { < MOD: "%" > }
TOKEN : { < ILT: ("0" ["X", "x"] (["0"-"9", "A"-"F", "a"-"f"])+) | ((<DIGITS>)+) > }
TOKEN : { < RLT: ((((<DIGITS>)+ "." (<DIGITS>)*) | ((<DIGITS>)* "." (<DIGITS>)+)) (["e", "E"] (["+", "-"])? (<DIGITS>)+)?) | ((<DIGITS>)+ ["e", "E"] (["+", "-"])? (<DIGITS>)+) > }
TOKEN : { < #DIGITS: ["0"-"9"] > }
TOKEN : { < CLT: "'"  (("\\" "~[]") | (~["'", "\\"])) "'"  > }
TOKEN : { < SLT: "\""  (("\\" "~[]") | (~["\"", "\\"]))* "\"" > }
TOKEN : { < ID: ["A"-"Z", "a"-"z"] ((["A"-"Z", "a"-"z", "_"])* ["A"-"Z", "a"-"z", "0"-"9"])? > }

bool Sentences(AST r): 
{}
{
    {
        r.type = ASTType.Sentences;
        r.children.clear();
        AST ast;
        ast = new AST();
        if(!Sentence(ast))
            return false;
        r.children.add(ast);
        ast = new AST();
        if(!Sentences_(ast))
            return false;
        r.children.add(ast);
        return true;
    }
}

bool Sentence(AST r):
{}
{
    {
        r.type = ASTType.Sentence;
        r.children.clear();
        AST ast;
        if(Type(ast)) {
            
        }
    }
}

AST Sentences_():
{}
{
    {
        return new AST();
    }
}